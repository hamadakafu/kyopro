use core::panic;
use std::cmp::Reverse;
use std::cmp::{max, min};
use std::collections::{HashMap, HashSet};
use std::ops::Add;

use itertools::Itertools;
use whiteread::parse_line;

const ten97: usize = 1000_000_007;

/// 2の逆元 mod ten97．割りたいときに使う
const inv2ten97: u128 = 500_000_004;

fn main() {}

/// 遅延セグメントツリー
/// 2つの完全2分木のデータ構造
/// 区間の最小の値を保存する
struct SegmentTree {
    // 深さ
    depth: usize,
    // originalの木
    data: Vec<usize>,
    // 遅延用の木
    lazy: Vec<usize>,
}

impl SegmentTree {
    const INF: usize = std::usize::MAX;
    fn new(depth: usize) -> Self{
        SegmentTree {
            depth,
            data: vec![INF; 2_usize.pow(depth as u32)],
            lazy: vec![INF; 2_usize.pow(depth as u32)],
        }
    }

    fn update(&mut self, x: usize, value: usize) {

    }

    fn eval(&mut self, x: usize) {
        if self.lazy[x] == st
    }

}

/// rootが0始まりの場合のaのchild(left, right)を返す
fn child(a: usize) -> (usize, usize) {
    (a * 2 + 1, a * 2 + 2)
}

/// rootが0始まりの場合のaのparentを返す
fn parent(a: usize) -> usize {
    if a == 0 {
        panic!("0's root is invalid!");
    }
    (a - 1) / 2
}
